#version 450

#extension GL_ARB_shading_language_include : enable

#include "include/webgl-noise/noise2D.glsl"
#include "include/constant.glsl"
#include "include/blade.glsl"
#include "include/random.glsl"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, offset = 0) uniform atomic_uint bladeIndexAtomic;

layout(std430, binding = 0) writeonly buffer GRASS_BLADES_SSBO
{
    Blade Blades[];
};

uniform vec2 PlacementOffset;
uniform vec3 InitialPos;
uniform uint HeightMapSize;
uniform sampler2D HeightMapTexture;
uniform float HeightMultiplier;
uniform float OccludeHeightOffset;
uniform float Time;
uniform sampler2D WindTexture;

uniform uint GrassInstances;

void main ()
{
    uvec2 id = gl_GlobalInvocationID.xy;

    if (id.x * id.y >= GrassInstances)
    {
        return;
    }

    // TODO Why 0 - 0.99?
    float snoise = snoise(id);
    float randomOffset = clamp(snoise, 0.0, 0.99);

    float spawnX = (float(id.x) / PlacementOffset.x) + randomOffset;
    float spawnZ = (float(id.y) / PlacementOffset.y) + randomOffset;

    vec3 finalPos = vec3(spawnX, 0.0f, spawnZ);
    vec3 revisedPos = InitialPos + finalPos;

    // TODO Distance Culling
    // uint distanceCulling = DistanceCulling(revisedPos);

    // TODO What happens if I don't cast to float?
    vec2 worldUV = vec2(spawnX, spawnZ);
    vec2 heightMapUV = worldUV * (1.0f / float(HeightMapSize));

    heightMapUV.x = clamp(heightMapUV.x, 0.0, 1.0);
    heightMapUV.y = clamp(heightMapUV.y, 0.0, 1.0);

    // Sample the height value
    float heightOffset = texture(HeightMapTexture, heightMapUV).r;
    revisedPos.y += heightOffset * HeightMultiplier;

    // TODO Frustum culling
    // vec4 clippingSpacePos = CamClippingMatrix * vec4(revisedPos, 1.0);
    // uint frustumCulling = FrustumCulling(clippingSpacePos);

    // TODO Occulusion culling
    // uint positionOcclusionTest = OcclusionCulling(clippingSpacePos);

    // Only use the balde grass generated location to check depth value will let some artifacts
    // Espically for the edge of the occluder
    // So add a second check using a simulated height value
    // vec4 clippingSpacePosHeight = CamClippingMatrix * vec4(revisedPos.x, revisedPos.y + OccludeHeightOffset, revisedPos.z, 1.0);
    // uint heightOcclusionTest = OcclusionCulling(clippingSpacePosHeight);
    // uint occlusionCulling = positionOcclusionTest || heightOcclusionTest;

    // if (distanceCulling == 1 && frustumCulling == 1 && occlusionCulling == 1)
//    {

        // Sample wind using timed UV coordinate
        vec2 sampleUV = worldUV + Time * 0.12f;

        float windOffset = texture(WindTexture, sampleUV, 0).x;

        Blade blade;

        blade.position = revisedPos;
        blade.windOffset = windOffset;

        const uint idx = atomicCounterIncrement(bladeIndexAtomic);
//        const uint idx = gl_GlobalInvocationID.x * gl_NumWorkGroups.x * gl_WorkGroupSize.x +
//                        gl_GlobalInvocationID.y * gl_NumWorkGroups.z * gl_WorkGroupSize.z + gl_GlobalInvocationID.z;
        Blades[idx] = blade;
//    }
}