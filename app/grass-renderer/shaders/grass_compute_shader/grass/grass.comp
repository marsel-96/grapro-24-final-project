#version 450

#extension GL_ARB_shading_language_include : enable

#include "include/webgl-noise/noise2D.glsl"
#include "include/hash-without-sine/hash.glsl"
#include "include/constant.glsl"
#include "include/blade.glsl"
#include "include/random.glsl"
#include "include/culling.glsl"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, offset = 0) uniform atomic_uint bladeIndexAtomic;
layout(std430, binding = 0) writeonly buffer GRASS_BLADES_SSBO
{
    GrassBlade Blades[];
};

uniform uint Resolution;

uniform float GrassSpacing;
uniform vec3 PlaneCentre;

uniform float GrassBladeMapsSize;

uniform sampler2D GrassBladeHeightMap;
uniform sampler2D GrassBladeTypeMap;
uniform float GrassBladeHeightMin;
uniform float GrassBladeHeightMax;
uniform float GrassBladeHeightMultiplier;
uniform float GrassBladeHeightJitter;
uniform float GrassBaseBend;
uniform float GrassBendOffset;
uniform float GrassBaseWidth;
uniform float GrassBaseSideCurve;
uniform float GrassWidthOffset;
uniform float GrassSideCurveOffset;

uniform float JitterStrength;

uniform mat4 ViewProjectionMatrix;
uniform mat4 WorldMatrix;

uniform sampler2D HeightMapTexture;
uniform float HeightMapSize;
uniform float HeightMultiplier;
uniform vec2 TerrainSize;

float GetHeight(vec2 uv, vec2 hash)
{
    return texture(HeightMapTexture, uv).r * HeightMultiplier;
}

float GetGrassBladeHeight(vec2 uv, vec2 hash)
{
    return texture(GrassBladeHeightMap, uv).r;
}

vec3 GetPosition(uvec2 laneId, vec2 hash)
{
    float jitterX = hash.x;
    float jitterZ = hash.y;

    vec3 position = vec3(laneId.x, 0, laneId.y) * GrassSpacing;
    // Jitter to range [JitterStrength, -JitterStrength]
    vec3 jitter = (vec3(jitterX, 0, jitterZ) * 2 - 1) * JitterStrength;

    return position + jitter;
}

uint GetGrassBladeType(vec2 uv, vec2 hash)
{
    vec4 texels = textureGather(GrassBladeTypeMap, uv, 0);
    vec2 texelPos = fract(uv * GrassBladeMapsSize);

    vec4 weights = vec4(
        texelPos.x * texelPos.y,
        (1 - texelPos.x) * texelPos.y,
        (1 - texelPos.x) * (1 - texelPos.y),
        texelPos.x * (1 - texelPos.y)
    );

    // TODO: Index of the grass blade type, now useless. Please future me do use it for something
    return uint(
        randomWeighted(texels, weights, hash) * 255
    );
}

void main ()
{
    uvec2 id = gl_GlobalInvocationID.xy;
    vec2 hash = hash22(id.xy);

    if (id.x >= Resolution && id.y >= Resolution)
    {
        return;
    }

    // Position Coordinates are in the range [0, TerrainSize]
    vec3 position = GetPosition(id, hash);

    // UV Coordinates have to consider the terrain size
    vec2 uv = clamp(position.xz / TerrainSize, 0.0, 1.0);

    position.y = GetHeight(uv, hash);

    // TODO: Frustum culling, Distance culling, Occlusion culling
//    vec4 worldPositon = WorldMatrix * vec4(position, 1.0);
//    vec4 clipPosition = ViewProjectionMatrix * worldPositon;
//
//    if (FrustumCulling(clipPosition))
//    {
//        return;
//    }

    float grassBladeHeight = GetGrassBladeHeight(uv, hash);
    grassBladeHeight += hash.x * GrassBladeHeightJitter;
    if (grassBladeHeight <= GrassBladeHeightMin)
    {
        return;
    }
    uint indexGrassBlade = GetGrassBladeType(uv, hash);

    GrassBlade blade;

    const uint idx = atomicCounterIncrement(bladeIndexAtomic);

    vec2 randomFacing = hash22(id.yx) - 0.5;

    blade.position = PlaneCentre + position;
    blade.height = clamp(grassBladeHeight * GrassBladeHeightMultiplier, GrassBladeHeightMin, GrassBladeHeightMax);
    blade.grassType = indexGrassBlade;
    blade.hash = hash12(hash);
    blade.width = GrassBaseWidth + hash.x * GrassWidthOffset;
    blade.tilt = blade.height - 0.25; // If equal to height, the blade is vertical
    blade.bend = GrassBaseBend + hash.y * hash.x * GrassBendOffset; // TODO the more the height the more the bend
    blade.sideCurve = GrassBaseSideCurve + hash.y * GrassSideCurveOffset; // Middle point curve
    blade.facing = normalize(randomFacing);
    blade.windForce = 1.0;
    blade.clumpColor = 1.0;
    blade.clumpFacing = vec2(0.5, 0.5);
   
    Blades[idx] = blade;

}